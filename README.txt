====Scala Macro Format====

macro-format is a collection of small and useful macros for scala.
Current version has 65 lines of code and includes:


* `printType` macro.
This may be useful if your IDE will get mad,
but you still want to understand the type of a complex code. Examples:

	val i = printType(1) // Expression 1 has type [Int(1)]
	printType(i) // Expression i has type [Int]
	val list = List(1,2,3)
	val grouped = printType(list.groupBy(_ % 2)) // Expression list.groupBy[Int](((x$1: Int) => x$1.%(2))) has type [scala.collection.immutable.Map[Int,List[Int]]]
	printType(grouped.get(0)) // Expression grouped.get(0) has type [Option[List[Int]]]

The comment on the right is what the compiler will print while compiling.
And you may see from usages and assignments that the macro has no effect at run time.


* a macro that is defined as `prettyFormat(params: Any*): String`
Example usages compared to a simple println:

	println("hi")
	prettyFormat("hi")

	val i = 1
	println(s"i = $i")
	prettyFormat(i) // yes, it will return "i = 1" !

	prettyFormat("a user here ", user.id, user.name)
	println(s"a user here, user.id() = ${user.id}, user.name() = ${user.name}")

	prettyFormat(if (2 > 1) "bigger" else "not bigger")
	println(s"if (2 > 1) \"bigger\" else \"not bigger\" = ${if (2 > 1) "bigger" else "not bigger"}")

BTW, this macro doesn't really print anything, just returns a string,
and that means you can put it inside your favorite logger.


* the last macro is very stupid and probably not useful at all :-)
It's called `onlyWithCompileKey(body: T)`.
If you launch your compiler with some tricky key or System.property,
then the code in "body" will be eliminated completely, from run-time and even from the byte-code.
This code:
	onlyWithCompileKey(sys.exit(-1))
will do nothing, it will not even have a line like "if ***" in the byte-code.

But if, while compiling, you will have a tricky System.property,
then the generated byte-code will have a strict instruction to execute sys.exit(-1).

If you're interested, see the Macro.scala code.
You'll see that to enable execution you have to set
an environment variable or System.property at compile time.


====How to use====
TODO !!!!!!!!!!!!


====Further Plans====
release a version for ScalaJs.


====Inspiration====
The main source of inspiration is: https://github.com/adamw/scala-macro-debug
Unfortunately, it has many disadvantages:

* it has no method `printType`, which I find useful :P

* it has more SLOC (280 lines compared to 67:)

* its formatting mechanism is tightly coupled with System.out.println. So, you cannot use it with a custom logger.

* it's actually faulty. `debug(1,2)` expands into `print(1); print(", "); println(2);`.
This is obviously wrong in a multi-threaded system.
// In my implementation, the code is expanded to `new stringBuilder().apply(1: Any).apply(", ").apply(2: Any).toString()`

* it has no tests.

summing the above, I thought it would be useful to write my own implementation,
and I hope it has its strong sides.


Copyright: Vasya Novikov. License: GPL v3.

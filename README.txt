==== Scala Macro Format ====

macro-format is a collection of small and useful macros for scala.
Current version has 83 lines of code and has:


* a macro defined as `prettyPrint(params: Any*): String`
Examples:

	prettyPrint(1, 2, "hi") // when invoked, this method will print:
	// MyTest.scala:31 1, 2, hi

	prettyPrint("1" + 2)
	// MyTest.scala:32 "1".+(2) = 12

	prettyFormat("user here", user.id, request.id)
	// MyTest.scala:33 user here, user.id() = 1, request.id() = 17


* a macro defined as `prettyFormat(params: Any*): String`   Examples:

	prettyFormat("hi") // the macro will return the string "hi"

	val i = 1
	prettyFormat(i) // the macro will return the string "i = 1".

	prettyFormat("user here", user.id, user.name, user.isActivated, request.id)
	// the macro will return the string
	// "user here, user.id() = 1, user.name() = Bob, user.isActivated() = true, request.id() = 17"

This macro has no side-effects so you can wrap it with your custom logger.


* `typePrint` macro.
This may be useful if your IDE got mad,
but you still want to see the type of a complex code.

The comment is what the compiler will print while /compiling/.
And you may see from usages and assignments that the macro has no effect at run time. Examples:

	val i = 1
	val i2: Int = typePrint(i)  // MyTest.scala:52 expression has type Int

	val list = List(1, 2, 3)
	val grouped = typePrint(list.groupBy(_ % 2)) // MyTest.scala:54 expression has type scala.collection.immutable.Map[Int,List[Int]]

	typePrint(grouped.get(1)) // MyTest.scala:55 expression has type Option[List[Int]]


* the last macro is very stupid and probably not useful at all :-)
It's called `onlyWithCompileKey(body: T)`.
By default, the code in "body" is just eliminated completely. From run-time and even from byte-code.
This code:
	onlyWithCompileKey(sys.exit(-1))
will do nothing, it will not even have a line like "if ***" in the byte-code.

But if, while compiling, you will set System.property "macro.compileWithDebug" to "true",
then your `body` goes straight to the generated byte-code.
So, you have an option to eliminate some of the code at compilation phase.
This gives you a possibility to wrap heavy debug code in this block,
and compile a production server with "debug" disabled.


==== How to use ====

First, you have to choose a version, dependent on your own scala version and whether you use ScalaJs.
If you use scala-2.10 and you don't use ScalaJS -- v0.6_scala2.10
If you use scala-2.11 and you don't use ScalaJS -- v0.6_scala2.11
If you use scala-2.10 and you do use ScalaJS -- v0.6_scala2.10_sjs0.5.0
If you use scala-2.11 and you do use ScalaJS -- v0.6_scala2.11_sjs0.5.0

Ok, so you chose your version, for example v0.6_scala2.11

Now, add to your build.sbt or Boot.scala:

	lazy val macroFormat = uri("git://gitorious.org/macro-format/macro-format.git#v0.6_scala2.11")
	lazy val root = Project("root", file(".")).dependsOn(macroFormat)

To use the macro itself:

	import net.pointsgame.macros.Macro._
	val a = 2
	println(prettyFormat("hi", a + 1))

For a Maven project you have to: clone the repo, check-out the version you want,
do a publish-local and include the dependency in your project.


==== Inspiration ====

The main source of inspiration is: https://github.com/adamw/scala-macro-debug
However:

* it has no method `typePrint`, which I find useful :P

* it has 280 SLOC comparing to 83 in this project.

* its formatting mechanism are tightly coupled with System.out.println.
You cannot use that lib with a custom logger.

* it's actually faulty. `debug(1,2)` expands into `print(1); print(", "); println(2);`.
This is obviously wrong in a multi-threaded system.
// In my implementation, the code is expanded to `new stringBuilder().apply(1: Any).apply(", ").apply(2: Any).toString()`

* it has no tests.

summing the above, I thought it would be useful to write my own implementation,
and I hope it has its strong sides.


==== Future plans ====

I may add other simple-stupid macros in the future, if I find any that would be nice and useful.
Few things that I have in mind:

* a macro that allows you to print the class and line number _from which the macro was called_.
That is possible, the only thing is to implement it.)

* a macro based on string-interpolators. So you could write, for example:

pretty"hello there, my name is $name, and here's information about me: $$status, $${user.id} $${request.id} $${user.isActivated}"

Benefits of such approach would be: simpler to read, simpler to write,
in-lined source code could possibly be returned as-is, not converted
to AST (we would have "user.id" instead of "user.id()")


==== Other notes ====

Main git repo: https://gitorious.org/macro-format/macro-format
Github mirror: https://github.com/vn971/macro-format

(Gitorious is just a free software alternative to github.)


Copyright: Vasya Novikov 2014. License: GPL v3.

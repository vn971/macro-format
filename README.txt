====Scala Macro Format====

macro-format is a collection of small and useful macros for scala.
Current version has 65 lines of code and includes:


* `printType` macro.
This may be useful if your IDE will get mad,
but you still want to understand the type of a complex code. Examples:

	val i = printType(1) // Expression 1 has type [Int(1)]
	printType(i) // Expression i has type [Int]
	val list = List(1,2,3)
	val grouped = printType(list.groupBy(_ % 2)) // Expression list.groupBy[Int](((x$1: Int) => x$1.%(2))) has type [scala.collection.immutable.Map[Int,List[Int]]]
	printType(grouped.get(0)) // Expression grouped.get(0) has type [Option[List[Int]]]

The comment on the right is what the compiler will print while compiling.
And you may see from usages and assignments that the macro has no effect at run time.


* a macro that is defined as `prettyFormat(params: Any*): String`
Example usages compared to a simple println:

	println("hi")
	prettyFormat("hi")

	val i = 1
	println(s"i = $i")
	prettyFormat(i) // yes, it will return "i = 1" !

	prettyFormat("a user here ", user.id, user.name)
	println(s"a user here, user.id() = ${user.id}, user.name() = ${user.name}")

	prettyFormat(if (2 > 1) "bigger" else "not bigger")
	println(s"if (2 > 1) \"bigger\" else \"not bigger\" = ${if (2 > 1) "bigger" else "not bigger"}")

BTW, this macro doesn't really print anything, just returns a string,
and that means you can put it inside your favorite logger.


* the last macro is very stupid and probably not useful at all :-)
It's called `onlyWithCompileKey(body: T)`.
By default, the code in "body" is just eliminated completely. From run-time and even from byte-code.
This code:
	onlyWithCompileKey(sys.exit(-1))
will do nothing, it will not even have a line like "if ***" in the byte-code.

But if, while compiling, you will set System.property "macro.compileWithDebug" to "true",
then your `body` goes straight to the generated byte-code.
So, you have an option to eliminate some of the code at compilation phase.
This gives you a possibility to wrap heavy debug code in this block,
and compile a production server with "debug" disabled.


====How to use====

For an SBT project with Scala-2.10, in your build.sbt or Boot.scala place:

	lazy val macroFormat = uri("git://gitorious.org/macro-format/macro-format.git#v0.4_scala2.10")
	lazy val root = Project("root", file(".")).dependsOn(macroFormat)

For an SBT project with Scala-2.11, in your build.sbt or Boot.scala place:

	lazy val macroFormat = uri("git://gitorious.org/macro-format/macro-format.git#v0.4_scala2.11")
	lazy val root = Project("root", file(".")).dependsOn(macroFormat)

For a Maven project: download the repo, check-out the version you want,
do a publish-local and include the dependency in your project.

To use the macro itself:

	import net.pointsgame.macros.Macro._
	val a = 2
	println(prettyFormat("hi", a + 1))


====Further Plans====
release a version for ScalaJs.


====Inspiration====
The main source of inspiration is: https://github.com/adamw/scala-macro-debug
Unfortunately, it has many disadvantages:

* it has no method `printType`, which I find useful :P

* it has more SLOC (280 lines compared to 67:)

* its formatting mechanism is tightly coupled with System.out.println. So, you cannot use it with a custom logger.

* it's actually faulty. `debug(1,2)` expands into `print(1); print(", "); println(2);`.
This is obviously wrong in a multi-threaded system.
// In my implementation, the code is expanded to `new stringBuilder().apply(1: Any).apply(", ").apply(2: Any).toString()`

* it has no tests.

summing the above, I thought it would be useful to write my own implementation,
and I hope it has its strong sides.


Copyright: Vasya Novikov. License: GPL v3.

==== Scala Macro Format ====

macro-format is a collection of small and useful macros for scala.
Current version has 67 lines of code and has:


* a macro defined as `prettyFormat(params: Any*): String`

	prettyFormat("hi") // the macro will return the string "hi"

	val i = 1
	prettyFormat(i) // the macro will return the string "i = 1".

	prettyFormat("user here", user.id, user.name, user.isActivated, request.id)
	// the macro will return the string
	// "user here, user.id() = 1, user.name() = Bob, user.isActivated() = true, request.id() = 17"

BTW, the macro has no side-effects so you can combine it with your favorite logger.


* `printType` macro.
This may be useful if your IDE got mad,
but you still want to see the type of a complex code. Examples:

	val i = printType(1) // Expression 1 has type [Int(1)]
	printType(i) // Expression i has type [Int]
	val list = List(1,2,3)
	val grouped = printType(list.groupBy(_ % 2)) // Expression list.groupBy[Int](((x$1: Int) => x$1.%(2))) has type [scala.collection.immutable.Map[Int,List[Int]]]
	printType(grouped.get(0)) // Expression grouped.get(0) has type [Option[List[Int]]]

The comment on the right is what the compiler will print while compiling.
And you may see from usages and assignments that the macro has no effect at run time.


* the last macro is very stupid and probably not useful at all :-)
It's called `onlyWithCompileKey(body: T)`.
By default, the code in "body" is just eliminated completely. From run-time and even from byte-code.
This code:
	onlyWithCompileKey(sys.exit(-1))
will do nothing, it will not even have a line like "if ***" in the byte-code.

But if, while compiling, you will set System.property "macro.compileWithDebug" to "true",
then your `body` goes straight to the generated byte-code.
So, you have an option to eliminate some of the code at compilation phase.
This gives you a possibility to wrap heavy debug code in this block,
and compile a production server with "debug" disabled.


==== How to use ====

First, you have to choose a version, dependent on your own scala version and whether you use ScalaJs.
If you use scala-2.10 and you don't use ScalaJS -- v0.5_scala2.10
If you use scala-2.11 and you don't use ScalaJS -- v0.5_scala2.11
If you use scala-2.10 and you do use ScalaJS -- v0.5_scala2.10_sjs0.5.0
If you use scala-2.11 and you do use ScalaJS -- v0.5_scala2.11_sjs0.5.0

Ok, so you chose your version, for example v0.5_scala2.11

Now, add to your build.sbt or Boot.scala:

	lazy val macroFormat = uri("git://gitorious.org/macro-format/macro-format.git#v0.5_scala2.11")
	lazy val root = Project("root", file(".")).dependsOn(macroFormat)

To use the macro itself:

	import net.pointsgame.macros.Macro._
	val a = 2
	println(prettyFormat("hi", a + 1))

For a Maven project you have to: clone the repo, check-out the version you want,
do a publish-local and include the dependency in your project.


==== Inspiration ====

The main source of inspiration is: https://github.com/adamw/scala-macro-debug
Unfortunately, it has many disadvantages:

* it has no method `printType`, which I find useful :P

* it has more SLOC (280 lines compared to 67:)

* its formatting mechanism is tightly coupled with System.out.println. So, you cannot use it with a custom logger.

* it's actually faulty. `debug(1,2)` expands into `print(1); print(", "); println(2);`.
This is obviously wrong in a multi-threaded system.
// In my implementation, the code is expanded to `new stringBuilder().apply(1: Any).apply(", ").apply(2: Any).toString()`

* it has no tests.

summing the above, I thought it would be useful to write my own implementation,
and I hope it has its strong sides.


==== Other notes ====

Main git repo: https://gitorious.org/macro-format/macro-format
Github mirror: https://github.com/vn971/macro-format

(Gitorious is just a free software alternative to github.)

I may add other simple-stupid macros in the future, if I find any that would be nice and useful.


Copyright: Vasya Novikov. License: GPL v3.
